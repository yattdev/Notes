react_learng_note

   WHY React ?
      1 Pour sa rapidité: React un utilise un DOM virtuel, et c’est ce qui fait
         sa rapidité.
      2 La re-utilisation des components
      3 Maintenu par facebook
      4 Employabilité

   JSX RULES
   Nested Components, React Tools
   Hosted React:
      Command to build for production: npm run build
      Hosted on Netify.com:
         With github: CI
         Or drag and drop: build directorie

#—————————————————————————————————————Beginning REACT—————————————————————————————————————
   UseState: useState (array, object)
         project: birthday (useState, destructure object)
   UseEffect: useEffect (simple, clean-up, fetch-data)
   conditionnal Rendering (row-operator(||, &&) and ternaire(?), multi-render, hidden)
      projects:
         Tours
            • Send function from parent to child
            • fecth data with axios, manage error,
            • Row and Ternaire operator
            • List item, and detail item (item === tour)
            • Read more button,
            • filter object array
         Review
            • Install(npm i react-icons —save) and using: site react-icons
            • Faire passer la liste des personnes en cliquant le btn(next, prev, surprise-me)
         Menu/Manuelle/dynamique
            • Comment filtre la liste des items kan on click le categorie
            • Ajouter manuellement et dynamiquement les btn des categories
         Slider
            • Ne pas oublier de verifier s’il faut cleaner l’event a chque fois que tu utilise useEffect
            •
   Forms:
      • On utilise: (onSubmit={handleSubmit}, value, onChange) pour generer les input
      • Pour les forms avec plusieurs input peu utiliser useState avec un object comme
      useState({id: , name: , etc})
   UseRef: useRef
      • On utilise useRef pour pointer un element du DOM afin d’avoir ces propriétes et les modifier
      • On utilise: const divContainerRef = useRef() et <div ref={divContainerRef}>
      • Utiliser dans le cas du Menu Hamburger
   UseReduce: useReduce
      • Un peu comme useState, mais donne un controle de comment les donner vont etre modifier
      • On utlise: const [state, dispatch] = useReducer(reducer, defautState)
         ▸ reducer est une inline fonction qui prend en parametre (state, action)
         ▸ defautState: c’est la valeur par defaut de state.
      • Personnellement je crois je vais l’utiliser dans les cas des formulaire, Cart (e.g: object)
         ▸ Pour le update et la creation, car action.type me donne le controle pour ça.
   Prop drilling:
      • C’est l’action de faire passer une fonctionnalité d’un parent a un enfant de niveau 2/+
         a travers d’autre enfant de niveau intermediaire alors qu’il n’en pas besoins.
      • On utilise useContext pour remedier a ce probleme.
   Context API / useContext:
      • Nous permet de partager des fonctionnalités a apartir des components vers les childs sans
      besoin de passer par d’autre childs intermediaire qui en non pas besoins.
      • Un peu comme (vuex) dans vuejs
      (send function from parent to child like props)
   Custom hooks:
      • On creer notre propre hook, sous forme de components ou utiliser (use) au debut de la fonction
      • Par exple: useFetch permet de faire le fetch vers l’api juste en lui passant l’url et retour {loading, datafected, error, whatever}
         On peu donc utiliser useFetch partout ou on veut faire du fetch
      • On peut trouver d’autre custom developper partout sur l’internet tres utiles
#—————————————————————————————————————ADVANCED REACT—————————————————————————————————————
   Prop types: Pour tester le retour des appelles API, afin de lever une exception lorsqu’il
   y’a une manque dans nos donner et aussi definir une valeur par defaut.
   React router:
      •  Creer des router entre nos components
      •  On a 2 facon de l’utiliser avec la V6.0 pour le moment parcequ’il change souvent
         ▸ 1er cas: BrowserRouter as Router >> Switch >> Route(path, element)
         ▸ 2e  cas: on utilise useRoutes, let routes = useRoutes([ { path: ‘’, element: component}])
            ▹ Dans ce 2e cas il faut emballer routes dans Router.
      • ‘React router params’: on accede au parametre de l’url avec ‘useParams’ from react-router-dom
         ▸ const { id } = useParams(): destructurer les parametres
      •  On a aussi ‘Link’ from react-router-dom, qui s’utilise de la meme facon dans les 2cas.
      • Attention avec map, il faut utiliser l’index comme key au lieu de l’id eg: key={index} intead key={id}
      • Le mot (exact) dans <Routen /> ’existe plus dans la version6, car ils ont ameliorer le systeme de matching
      • On utilise aussi Switch specifique lorsque nous voulons afficher une page d’ERREUR
      ————————————————————————————————OPTIMISATION DE L’APP——————————————————————————————————————-
   React memo: React.memo
      • Utiliser pour optimiser le rendu des les props
      • Lorsqu’on utilise, react ne rend plus de re-render avec la liste de items tant qu’il y’a pas eu de changement
      • On wrap le component qui prend en parametre la props avec: React.memo(component)
   UseCallback: useCallback
      • Utiliser pour optimiser le rendu des fonctions
      •  Lorsqu’on utilise, react ne fait plus de re-render lorsqu’on appelle la fonction tant que le retour de celle-ci n’est pas
         modifier.
      • utiliser pour wrapper la fonction passer comme props
   UseMemo: useMemo
      • Utiliser pour optimiser les calculs couté en temps et/ou memoire
      • Lorsqu’on utilise, react n’effectue plus ce calcul tant le retour ne change pas.
      • On wrap la fontion qui fait le calcul avec useMemo:
         ▸ const mostExpensive = useMemo(() => fonctionQuiFaitCalculExpensive(param), [param]) dependency est le param
